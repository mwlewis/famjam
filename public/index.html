<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>SillyFam Video Party üé≠üó£Ô∏è</title>
<style>
  :root { --bg:#0b1020; --card:#121a33; --accent:#7df8ff; --good:#92ff8b; --warn:#ffbd6b; --bad:#ff6b8b; }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 70% 10%, #16254a 0%, var(--bg) 60%);color:#e9f2ff;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
  header{display:flex;gap:.75rem;align-items:center;justify-content:center;flex-wrap:wrap;padding:12px}
  header .brand{font-weight:700;letter-spacing:.5px}
  .wrap{max-width:1200px;margin:0 auto;padding:10px}
  .controls{display:flex;gap:.5rem;flex-wrap:wrap;justify-content:center;align-items:center}
  .controls input, .controls button, .controls select, .controls label{
    background:#0e1730;border:1px solid #22315f;color:#e9f2ff;border-radius:10px;padding:.55rem .7rem;font-size:.95rem;outline:none
  }
  .controls label{display:flex; gap:.4rem; align-items:center; padding:.4rem .6rem}
  .controls button:hover{border-color:#3a57a0}
  .controls .primary{background:linear-gradient(90deg,#32d7ff,#8dfd7a);color:#051024;border:none;font-weight:700}
  .hint{opacity:.8;font-size:.9rem;text-align:center;margin-top:.35rem}
  .grid{display:grid;gap:10px;margin:12px auto 18px;grid-template-columns: repeat(auto-fit, minmax(240px,1fr));}
  .tile{position:relative;background:var(--card);border-radius:18px;overflow:hidden;aspect-ratio:16/10;box-shadow:0 10px 30px #0004;}
  video{width:100%;height:100%;object-fit:cover;display:block;background:#000;transform: scaleX(-1);}
  canvas.overlay{position:absolute;inset:0;pointer-events:none;transform: scaleX(-1);}
  .nameTag{position:absolute;left:10px;bottom:10px;background:#0b1534cc;padding:.25rem .5rem;border-radius:12px;font-size:.85rem}
  .badge{position:absolute;right:10px;top:10px;padding:.2rem .5rem;border-radius:999px;font-size:.75rem;background:#13204dee;border:1px solid #3851a7}
  .me .badge{background:#163a1a;border-color:#2b8b45}
  footer{opacity:.65;font-size:.85rem;text-align:center;padding:10px}
  .tiny{font-size:.8rem}
  .unmute-banner{position:fixed;left:50%;bottom:24px;transform:translateX(-50%);background:#0b1534cc;border:1px solid #3851a7;padding:.6rem 1rem;border-radius:12px;z-index:9999;backdrop-filter: blur(4px)}
  .unmute-banner button{background:#1d2a5a;border:1px solid #4a63c9;color:#e9f2ff;border-radius:10px;padding:.45rem .8rem;font-weight:600}
</style>
</head>
<body>
  <header><div class="brand">üé≠ SillyFam Video Party</div></header>
  <div class="wrap">
    <div class="controls">
      <input id="displayName" placeholder="Your name (e.g., Dad)" />
      <input id="room" placeholder="Room (e.g., family)" />
      <button id="join" class="primary">Join</button>
      <button id="leave">Leave</button>
      <button id="shuffle">Shuffle ü§™</button>
      <select id="sillyMode">
        <option value="auto" selected>Auto on speech</option>
        <option value="chaos">Chaos (6‚Äì10s)</option>
        <option value="calm">Calm (18‚Äì26s)</option>
        <option value="off">Off</option>
      </select>
      <button id="mute">Mute</button>
      <button id="camera">Camera</button>
      <label><input type="checkbox" id="fxToggle" checked /> Voice FX</label>
    </div>
    <div class="hint tiny">Share the URL + use the same Room. If you can't hear others, a **Tap to hear friends** banner will appear.</div>
    <div id="grid" class="grid"></div>
    <footer class="tiny">Up to 4 people per room. Masks + silly voices auto-rotate when you speak.</footer>
  </div>

  <!-- TFJS + Face Landmarks (MediaPipe Facemesh) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@4.22.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@4.22.0/dist/tf-converter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.22.0/dist/tf-backend-webgl.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection@1.0.6/dist/face-landmarks-detection.min.js"></script>
  <!-- Fallback: MediaPipe FaceMesh -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.4/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.4/drawing_utils.js"></script>

<script>
(() => {
  // ---------- Polyfills & TF backend warmup ----------
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r=0){
      r = Math.min(r, w/2, h/2);
      this.beginPath(); this.moveTo(x+r, y);
      this.arcTo(x+w, y,   x+w, y+h, r);
      this.arcTo(x+w, y+h, x,   y+h, r);
      this.arcTo(x,   y+h, x,   y,   r);
      this.arcTo(x,   y,   x+w, y,   r);
      this.closePath(); return this;
    };
  }
  let tfBackendReady = (async () => {
    try { await tf.setBackend('webgl'); } catch(e){}
    try { await tf.ready(); } catch(e){}
    if (tf.getBackend() !== 'webgl') { try { await tf.setBackend('cpu'); await tf.ready(); } catch(e){} }
  })();

  // ---------- UI refs ----------
  const grid = document.getElementById('grid');
  const btnJoin = document.getElementById('join');
  const btnLeave = document.getElementById('leave');
  const btnShuffle = document.getElementById('shuffle');
  const selMode = document.getElementById('sillyMode');
  const btnMute = document.getElementById('mute');
  const btnCamera = document.getElementById('camera');
  const inpName = document.getElementById('displayName');
  const inpRoom = document.getElementById('room');
  const fxToggle = document.getElementById('fxToggle');

  const wsURL = location.origin.replace(/^http/, 'ws'); // wss on Render

  if (!inpRoom.value) inpRoom.value = (location.hash.slice(1) || 'family');
  if (!inpName.value) inpName.value = 'Me';

  let myId = null, ws = null, room = null;
  let pcs = new Map(), peers = new Map();
  let local = { stream:null, processedAudioStream:null, audioCtx:null, voiceChain:null, maskMgr:null, tileEl:null, videoEl:null, canvasEl:null, vad:null, muted:false, camOn:true };
  let landmarksModel = null, mpFaceMesh = null, sillyMode = 'auto', chaosTimer = null;
  let unmuteBanner = null, useFX = true;

  function rand(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
  function lerp(a,b,t){ return a + (b-a)*t; }

  function showUnmuteBanner(){
    if (unmuteBanner) return;
    unmuteBanner = document.createElement('div');
    unmuteBanner.className = 'unmute-banner';
    unmuteBanner.innerHTML = '<span>Audio is paused by your browser.</span> <button id="unmuteBtn">üîä Tap to hear friends</button>';
    document.body.appendChild(unmuteBanner);
    document.getElementById('unmuteBtn').onclick = async () => {
      for (const p of peers.values()) { try { await p.audioEl?.play(); } catch(e){} }
      unmuteBanner?.remove(); unmuteBanner=null;
    };
  }

  // ---------- Tiles ----------
  function createTile(name, isMe=false){
    const tile = document.createElement('div'); tile.className = 'tile' + (isMe ? ' me' : '');
    const v = document.createElement('video'); v.autoplay = true; v.playsInline = true; v.muted = isMe;
    const c = document.createElement('canvas'); c.className = 'overlay';
    const tag = document.createElement('div'); tag.className = 'nameTag'; tag.textContent = name || 'Guest';
    const badge = document.createElement('div'); badge.className = 'badge'; badge.textContent = isMe ? 'You' : 'Friend';
    tile.appendChild(v); tile.appendChild(c); tile.appendChild(tag); tile.appendChild(badge);
    grid.appendChild(tile); return {tile, v, c, tag, badge};
  }
  function removeTile(el){ if (el && el.parentNode) el.parentNode.removeChild(el); }

  // ---------- VAD ----------
  function makeAnalyser(ctx, sourceNode){
    const analyser = ctx.createAnalyser(); analyser.fftSize = 1024;
    const data = new Uint8Array(analyser.fftSize); sourceNode.connect(analyser);
    const state = { speaking:false, tLastChange:0, onSpeak:()=>{}, onSilence:()=>{} };
    (function loop(){
      if (ctx.state === 'closed') return;
      analyser.getByteTimeDomainData(data);
      let sum = 0; for (let i=0;i<data.length;i++){ const v=(data[i]-128)/128; sum += v*v; }
      const rms = Math.sqrt(sum/data.length);
      const now = performance.now();
      const speakingNow = rms > 0.03;
      if (speakingNow && !state.speaking && now - state.tLastChange > 300) { state.speaking = true; state.tLastChange = now; state.onSpeak(); }
      if (!speakingNow && state.speaking && now - state.tLastChange > 500) { state.speaking = false; state.tLastChange = now; state.onSilence(); }
      requestAnimationFrame(loop);
    })(); return state;
  }

  // ---------- Detection (TFJS primary, MP fallback) with smoothing ----------
  async function estimateFaceBox(videoEl){
    try{
      await tfBackendReady;
      if (!landmarksModel) {
        landmarksModel = await faceLandmarksDetection.load(
          faceLandmarksDetection.SupportedPackages.mediapipeFacemesh,
          { maxFaces:1, shouldLoadIrisModel:false }
        );
      }
      const faces = await landmarksModel.estimateFaces({input:videoEl});
      if (faces && faces[0]){
        const f = faces[0];
        const pts = f.scaledMesh || f.keypoints?.map(k=>[k.x,k.y]);
        if (pts && pts.length){
          let minX=1e9,minY=1e9,maxX=-1e9,maxY=-1e9;
          for (const p of pts){ minX=Math.min(minX,p[0]); maxX=Math.max(maxX,p[0]); minY=Math.min(minY,p[1]); maxY=Math.max(maxY,p[1]); }
          const nose = pts[1] || [ (minX+maxX)/2, minY + (maxY-minY)*0.55 ];
          return {minX, minY, maxX, maxY, noseX:nose[0], noseY:nose[1], srcW: videoEl.videoWidth, srcH: videoEl.videoHeight};
        }
      }
    }catch(e){ /* fall through to MP */ }
    if (!mpFaceMesh){
      mpFaceMesh = new FaceMesh({ locateFile: (file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/${file}` });
      mpFaceMesh.setOptions({ maxNumFaces:1, refineLandmarks:false, minDetectionConfidence:0.5, minTrackingConfidence:0.6 });
    }
    return await new Promise((resolve) => {
      mpFaceMesh.onResults((res)=>{
        const lm = res.multiFaceLandmarks && res.multiFaceLandmarks[0];
        if (!lm) return resolve(null);
        let minX=1e9,minY=1e9,maxX=-1e9,maxY=-1e9;
        for (const p of lm){ const x=p.x*videoEl.videoWidth, y=p.y*videoEl.videoHeight;
          minX=Math.min(minX,x); maxX=Math.max(maxX,x); minY=Math.min(minY,y); maxY=Math.max(maxY,y); }
        const nose = lm[1] ? [lm[1].x*videoEl.videoWidth, lm[1].y*videoEl.videoHeight] : [ (minX+maxX)/2, minY + (maxY-minY)*0.55 ];
        resolve({minX,minY,maxX,maxY,noseX:nose[0],noseY:nose[1], srcW: videoEl.videoWidth, srcH: videoEl.videoHeight});
      });
      mpFaceMesh.send({ image: videoEl });
    });
  }

  // ---------- Funny Masks (inspired by your image) ----------
  const MaskTypes = ['bananaApe','coffeeBird','goldShark','hotdogSlugger','elephantSandals','tireFrog'];
  function pickMask(){ return MaskTypes[Math.floor(Math.random()*MaskTypes.length)] }
  class MaskManager {
    constructor(videoEl, canvasEl){
      this.video=videoEl; this.canvas=canvasEl; this.ctx=canvasEl.getContext('2d');
      this.current=pickMask(); this.running=true; this.lastBox=null; this._next=0;
      this.loop();
    }
    set(mask){ this.current = mask || pickMask(); }
    async loop(){
      const draw = async (t) => {
        if (!this.running) return;
        const v=this.video, c=this.canvas, ctx=this.ctx;
        if (v.videoWidth && v.videoHeight){
          if (c.width !== v.clientWidth || c.height !== v.clientHeight){ c.width = v.clientWidth; c.height = v.clientHeight; }
          if (!this._next || t - this._next >= 60) { // ~16 FPS
            try{
              const box = await estimateFaceBox(v);
              if (box){
                if (!this.lastBox) this.lastBox = box;
                const a=0.25; // smoothing
                this.lastBox = {
                  minX: lerp(this.lastBox.minX, box.minX, a),
                  minY: lerp(this.lastBox.minY, box.minY, a),
                  maxX: lerp(this.lastBox.maxX, box.maxX, a),
                  maxY: lerp(this.lastBox.maxY, box.maxY, a),
                  noseX: lerp(this.lastBox.noseX, box.noseX, a),
                  noseY: lerp(this.lastBox.noseY, box.noseY, a),
                  srcW: box.srcW, srcH: box.srcH
                };
              }
            }catch(e){}
            this._next = t;
          }
          ctx.clearRect(0,0,c.width,c.height);
          const b = this.lastBox;
          if (b){
            const sx = c.width / b.srcW, sy = c.height / b.srcH;
            const x=b.minX*sx, y=b.minY*sy, w=(b.maxX-b.minX)*sx, h=(b.maxY-b.minY)*sy;
            const nx = b.noseX*sx, ny = b.noseY*sy;
            this.drawMask(ctx, x, y, w, h, nx, ny);
          }
        }
        requestAnimationFrame(draw);
      }; requestAnimationFrame(draw);
    }
    drawMask(ctx,x,y,w,h,nx,ny){
      const cx=x+w/2;
      ctx.save(); ctx.shadowColor='#0008'; ctx.shadowBlur=8;
      switch(this.current){
        case 'bananaApe':{
          // banana peel hat + peel curls + face tint
          const top = y + h*0.05;
          const peel = (dir)=>{
            ctx.beginPath();
            ctx.moveTo(cx, top);
            ctx.bezierCurveTo(cx+dir*w*0.25, top+h*0.05, cx+dir*w*0.22, top+h*0.26, cx+dir*w*0.02, top+h*0.22);
            ctx.bezierCurveTo(cx-dir*w*0.10, top+h*0.20, cx-dir*w*0.18, top+h*0.06, cx, top);
            ctx.closePath();
          };
          const grad = ctx.createLinearGradient(cx-w*0.4, top, cx+w*0.4, top+h*0.3);
          grad.addColorStop(0, '#ffe877'); grad.addColorStop(1, '#d8b43a');
          ctx.fillStyle=grad; peel(+1); ctx.fill(); peel(-1); ctx.fill();
          ctx.globalAlpha=0.35; ctx.fillStyle='#ff4e4e'; ctx.beginPath(); ctx.ellipse(cx, y + h*0.48, w*0.28, h*0.24, 0, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
          break;
        }
        case 'coffeeBird':{
          const g=ctx.createLinearGradient(cx-w*0.4,0,cx+w*0.4,0); g.addColorStop(0,'#141414'); g.addColorStop(1,'#2a2a2a'); ctx.fillStyle=g;
          ctx.beginPath(); ctx.roundRect(cx - w*0.30, y + h*0.30, w*0.24, h*0.17, 14); ctx.fill();
          ctx.beginPath(); ctx.roundRect(cx + w*0.06, y + h*0.30, w*0.24, h*0.17, 14); ctx.fill();
          ctx.fillStyle='#ff9b2f'; ctx.beginPath(); ctx.moveTo(nx, ny+h*0.08); ctx.quadraticCurveTo(nx+w*0.36, ny+h*0.02, nx+w*0.20, ny+h*0.24); ctx.quadraticCurveTo(nx+w*0.03, ny+h*0.18, nx, ny+h*0.08); ctx.fill();
          ctx.globalAlpha=0.65; ctx.strokeStyle='#cfa66b'; for(let i=0;i<3;i++){ ctx.beginPath(); ctx.moveTo(x - w*0.05 + i*10, y + h*0.56); ctx.bezierCurveTo(x + i*10, y + h*0.50, x + w*0.04 + i*10, y + h*0.42, x + w*0.08 + i*10, y + h*0.36); ctx.stroke(); }
          ctx.globalAlpha=1; break;
        }
        case 'goldShark':{
          ctx.fillStyle='#ffd347'; ctx.beginPath(); ctx.moveTo(cx, y - h*0.02); ctx.lineTo(cx + w*0.09, y + h*0.14); ctx.lineTo(cx - w*0.09, y + h*0.14); ctx.closePath(); ctx.fill();
          const shoe = (sx)=>{ ctx.beginPath(); ctx.roundRect(sx, y + h*0.86, w*0.22, h*0.1, 8); ctx.fillStyle='#f3c12c'; ctx.fill(); ctx.strokeStyle='#a98300'; ctx.stroke(); };
          shoe(cx - w*0.30); shoe(cx + w*0.08);
          break;
        }
        case 'hotdogSlugger':{
          ctx.fillStyle='#f7a654'; ctx.beginPath(); ctx.roundRect(cx - w*0.14, y + h*0.28, w*0.28, h*0.50, 22); ctx.fill();
          ctx.fillStyle='#d97c2c'; ctx.beginPath(); ctx.roundRect(cx - w*0.18, y + h*0.30, w*0.08, h*0.46, 18); ctx.fill();
          ctx.beginPath(); ctx.roundRect(cx + w*0.10, y + h*0.30, w*0.08, h*0.46, 18); ctx.fill();
          ctx.strokeStyle='#f0d21a'; ctx.lineWidth=6; ctx.beginPath(); ctx.moveTo(cx - w*0.08, y + h*0.35); ctx.bezierCurveTo(cx, y+h*0.45, cx - w*0.04, y+h*0.60, cx + w*0.02, y+h*0.70); ctx.stroke();
          ctx.strokeStyle='#a5733a'; ctx.lineWidth=6; ctx.beginPath(); ctx.moveTo(cx - w*0.36, y + h*0.68); ctx.lineTo(cx - w*0.18, y + h*0.73); ctx.stroke();
          break;
        }
        case 'elephantSandals':{
          ctx.strokeStyle='#7dbb7c'; ctx.lineWidth=10; ctx.lineCap='round';
          ctx.beginPath(); ctx.moveTo(nx - w*0.04, ny + h*0.08); ctx.bezierCurveTo(nx - w*0.20, ny + h*0.18, nx - w*0.12, ny + h*0.28, nx - w*0.26, ny + h*0.34); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(nx + w*0.04, ny + h*0.08); ctx.bezierCurveTo(nx + w*0.20, ny + h*0.18, nx + w*0.12, ny + h*0.28, nx + w*0.26, ny + h*0.34); ctx.stroke();
          ctx.fillStyle='#ff5c5c'; ctx.beginPath(); ctx.roundRect(cx - w*0.28, y + h*0.86, w*0.2, h*0.08, 6); ctx.fill();
          ctx.beginPath(); ctx.roundRect(cx + w*0.08, y + h*0.86, w*0.2, h*0.08, 6); ctx.fill();
          ctx.strokeStyle='#c9c3a2'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(cx + w*0.34, y + h*0.52, 10, 0, Math.PI*2); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(cx + w*0.34, y + h*0.52); ctx.lineTo(cx + w*0.34, y + h*0.47); ctx.moveTo(cx + w*0.34, y + h*0.52); ctx.lineTo(cx + w*0.39, y + h*0.52); ctx.stroke();
          break;
        }
        case 'tireFrog':{
          ctx.strokeStyle='#0b0b0b'; ctx.lineWidth=10;
          ctx.beginPath(); ctx.ellipse(cx, y + h*0.52, w*0.38, h*0.28, 0, 0, Math.PI*2); ctx.stroke();
          // tread dashes
          ctx.lineWidth=3; for(let i=-8;i<=8;i++){ ctx.beginPath(); ctx.moveTo(cx + i*w*0.04, y + h*0.40); ctx.lineTo(cx + i*w*0.04, y + h*0.64); ctx.stroke(); }
          ctx.fillStyle='#6bd178'; ctx.beginPath(); ctx.arc(cx - w*0.18, y + h*0.22, w*0.06, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(cx + w*0.18, y + h*0.22, w*0.06, 0, Math.PI*2); ctx.fill();
          ctx.fillStyle='#0b0b0b'; ctx.beginPath(); ctx.arc(cx - w*0.18, y + h*0.22, w*0.025, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(cx + w*0.18, y + h*0.22, w*0.025, 0, Math.PI*2); ctx.fill();
          break;
        }
      }
      ctx.restore();
    }
  }

  // ---------- Voices ----------
  const VoiceTypes = ['chipmunk','giant','robot','alien','radio','monster'];
  function pickVoiceType(){ return VoiceTypes[rand(0, VoiceTypes.length-1)] }

  async function buildVoiceChain(ctx){
    await ctx.audioWorklet.addModule('worklets/pitch-shifter.js');
    const input = ctx.createGain();
    const output = ctx.createMediaStreamDestination();
    const pre = ctx.createGain(); pre.gain.value = 1.0;

    const shifter = new AudioWorkletNode(ctx, 'pitch-shifter-processor', { parameterData: { pitch: 1.0, mix: 1.0 } });
    const hp = ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=120;
    const bp = ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1400; bp.Q.value=0.9;
    const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=8000;
    const crush = ctx.createWaveShaper(); // faux bitcrush
    function makeCrusher(bits=8){
      const n = 1<<bits; const curve = new Float32Array(65536);
      for(let i=0;i<curve.length;i++){ const x = i/32768-1; curve[i] = Math.round(x*n)/n; }
      crush.curve = curve; crush.oversample='none';
    }
    makeCrusher(8);
    const trem = ctx.createGain(); trem.gain.value=1.0;
    const tremLFO = ctx.createOscillator(); tremLFO.frequency.value=0; const tremDepth = ctx.createGain(); tremDepth.gain.value=0; tremLFO.connect(tremDepth); tremDepth.connect(trem.gain); tremLFO.start();

    input.connect(pre); pre.connect(shifter); shifter.connect(hp); hp.connect(bp); bp.connect(lp); lp.connect(crush); crush.connect(trem); trem.connect(output);

    function setVoice(type){
      switch(type){
        case 'chipmunk': shifter.parameters.get('pitch').setValueAtTime(1.7, ctx.currentTime); shifter.parameters.get('mix').setValueAtTime(1.0, ctx.currentTime); bp.frequency.value=1800; lp.frequency.value=9000; tremLFO.frequency.value=6; tremDepth.gain.value=0.15; makeCrusher(10); break;
        case 'giant':    shifter.parameters.get('pitch').setValueAtTime(0.65, ctx.currentTime); shifter.parameters.get('mix').setValueAtTime(1.0, ctx.currentTime); bp.frequency.value=700;  lp.frequency.value=4200; tremLFO.frequency.value=4; tremDepth.gain.value=0.08; makeCrusher(9); break;
        case 'robot':    shifter.parameters.get('pitch').setValueAtTime(1.0, ctx.currentTime); shifter.parameters.get('mix').setValueAtTime(0.0, ctx.currentTime); bp.frequency.value=1200; lp.frequency.value=4800; tremLFO.frequency.value=30; tremDepth.gain.value=0.6; makeCrusher(6); break;
        case 'alien':    shifter.parameters.get('pitch').setValueAtTime(1.25, ctx.currentTime); shifter.parameters.get('mix').setValueAtTime(1.0, ctx.currentTime); bp.frequency.value=1400; lp.frequency.value=7000; tremLFO.frequency.value=11; tremDepth.gain.value=0.25; makeCrusher(9); break;
        case 'radio':    shifter.parameters.get('pitch').setValueAtTime(1.0, ctx.currentTime); shifter.parameters.get('mix').setValueAtTime(0.0, ctx.currentTime); bp.frequency.value=1600; bp.Q.value=6; lp.frequency.value=3200; tremLFO.frequency.value=0; tremDepth.gain.value=0; makeCrusher(12); break;
        case 'monster':  shifter.parameters.get('pitch').setValueAtTime(0.55, ctx.currentTime); shifter.parameters.get('mix').setValueAtTime(1.0, ctx.currentTime); bp.frequency.value=600;  lp.frequency.value=3600; tremLFO.frequency.value=8; tremDepth.gain.value=0.18; makeCrusher(7); break;
      }
    }
    return { input, output, setVoice };
  }

  function randomizeMySillies(trigger='auto'){ if(!local.maskMgr||!local.voiceChain) return; local.maskMgr.set(pickMask()); local.voiceChain.setVoice(pickVoiceType()); if(local.tileEl){ const badge=local.tileEl.querySelector('.badge'); badge.textContent=(trigger==='speak'?'‚ú® New Sillies!':'üé≤ Shuffle!'); setTimeout(()=>badge.textContent='You',1200);} }

  // ---------- Local media ----------
  async function startLocal(){
    if (local.stream) return;
    local.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    await local.audioCtx.resume();
    local.voiceChain = await buildVoiceChain(local.audioCtx);
    local.stream = await navigator.mediaDevices.getUserMedia({
      video:{ facingMode:'user', width:{ideal:640}, height:{ideal:360} },
      audio:{ echoCancellation:true, noiseSuppression:true, autoGainControl:true }
    });
    const src = local.audioCtx.createMediaStreamSource(local.stream);
    src.connect(local.voiceChain.input);
    local.processedAudioStream = local.voiceChain.output.stream;
    const {tile, v, c, tag} = createTile(inpName.value || 'Me', true);
    local.tileEl=tile; local.videoEl=v; local.canvasEl=c; tag.textContent=(inpName.value||'Me');
    v.srcObject = local.stream; v.play().catch(()=>{});
    local.maskMgr = new MaskManager(v, c);
    const analyserSrc = local.audioCtx.createMediaStreamSource(local.processedAudioStream);
    local.vad = makeAnalyser(local.audioCtx, analyserSrc);
    local.vad.onSpeak = () => { if (sillyMode==='auto') randomizeMySillies('speak'); };
    local.voiceChain.setVoice('chipmunk');
    setChaosTimer();
  }
  function stopLocal(){
    if (chaosTimer) { clearTimeout(chaosTimer); chaosTimer=null; }
    for (const tr of (local.stream?.getTracks()||[])) tr.stop();
    local.stream=null; local.processedAudioStream=null;
    if (local.audioCtx && local.audioCtx.state!=='closed') local.audioCtx.close();
    local.audioCtx=null;
    if (local.tileEl) removeTile(local.tileEl);
    local.tileEl=local.videoEl=local.canvasEl=null; local.maskMgr=null; local.vad=null;
  }
  function setChaosTimer(){
    if (chaosTimer) clearTimeout(chaosTimer);
    if (sillyMode==='chaos'){ chaosTimer=setTimeout(()=>{ randomizeMySillies('timer'); setChaosTimer(); }, rand(6000,10000)); }
    else if (sillyMode==='calm'){ chaosTimer=setTimeout(()=>{ randomizeMySillies('timer'); setChaosTimer(); }, rand(18000,26000)); }
  }

  // ---------- WebRTC helpers ----------
  function pcConfig(){
    return {
      iceServers: [
        { urls: ['stun:stun.l.google.com:19302', 'stun:global.stun.twilio.com:3478'] },
        { urls: 'turn:openrelay.metered.ca:80',  username: 'openrelayproject', credential: 'openrelayproject' },
        { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' },
        { urls: 'turn:openrelay.metered.ca:443?transport=tcp', username: 'openrelayproject', credential: 'openrelayproject' }
      ]
    };
  }
  function chooseAudioTrack(){ return useFX ? local.processedAudioStream.getAudioTracks()[0] : local.stream.getAudioTracks()[0]; }
  async function addTracksTo(pc){
    const audioTrack = chooseAudioTrack();
    const camTrack = local.stream.getVideoTracks()[0];
    pc.addTrack(audioTrack, useFX ? local.processedAudioStream : local.stream);
    pc.addTrack(camTrack, local.stream);
  }
  function replaceAudioTrackOnAllPCs(){
    const newTrack = chooseAudioTrack();
    for (const pc of pcs.values()){
      const sender = pc.getSenders().find(s => s.track && s.track.kind === 'audio');
      if (sender) sender.replaceTrack(newTrack);
    }
  }
  async function createPeer(peerId, isCaller){
    const pc = new RTCPeerConnection(pcConfig());
    pcs.set(peerId, pc);
    await addTracksTo(pc);
    pc.onicecandidate = (ev)=>{ if(ev.candidate){ ws.send(JSON.stringify({type:'signal', target:peerId, data:{candidate:ev.candidate}})); } };
    let remoteStream = new MediaStream();
    pc.ontrack = (ev)=>{
      const track = ev.track;
      remoteStream.addTrack(track);
      let peer = peers.get(peerId);
      if(!peer){
        const {tile, v, c, tag, badge} = createTile(`Guest ${peerId.slice(-4)}`, false);
        const a = document.createElement('audio'); a.autoplay = true; a.playsInline = true; a.muted = false; a.style.position='absolute'; a.style.left='-9999px';
        tile.appendChild(a);
        peer={tileEl:tile, videoEl:v, canvasEl:c, audioEl:a, nameEl:tag, badgeEl:badge, vad:null, maskMgr:null, remoteStream};
        peers.set(peerId, peer);
      } else {
        peer.remoteStream = remoteStream;
      }
      peer.videoEl.srcObject = remoteStream; peer.videoEl.play?.().catch(()=>{});
      peer.audioEl.srcObject = remoteStream; peer.audioEl.play().catch(()=>showUnmuteBanner());
      if(!peer.maskMgr) peer.maskMgr = new MaskManager(peer.videoEl, peer.canvasEl);
      if(local.audioCtx && remoteStream.getAudioTracks().length && !peer.vad){
        const peerSrc = local.audioCtx.createMediaStreamSource(remoteStream);
        peer.vad = makeAnalyser(local.audioCtx, peerSrc);
        peer.vad.onSpeak = () => { if (sillyMode!=='off' && peer.badgeEl){ peer.maskMgr.set(pickMask()); peer.badgeEl.textContent='Talking üé≠'; setTimeout(()=>peer.badgeEl.textContent='Friend',1000); } };
      }
    };
    pc.onconnectionstatechange = () => { if (['failed','closed','disconnected'].includes(pc.connectionState)) dropPeer(peerId); };
    if(isCaller){ const offer = await pc.createOffer(); await pc.setLocalDescription(offer); ws.send(JSON.stringify({type:'signal', target:peerId, data:{ sdp: pc.localDescription }})); }
  }
  function dropPeer(peerId){
    const pc = pcs.get(peerId); if (pc) { try{ pc.close(); }catch{} pcs.delete(peerId); }
    const p = peers.get(peerId); if (p) { removeTile(p.tileEl); peers.delete(peerId); }
  }

  // ---------- Signaling & buttons ----------
  async function joinRoom(){
    sillyMode = selMode.value;
    useFX = fxToggle.checked;
    await startLocal();
    ws = new WebSocket(wsURL);
    room = (inpRoom.value || 'family').trim();
    ws.onopen = () => { ws.send(JSON.stringify({ type:'join', room })); };
    ws.onmessage = async (ev) => {
      const msg = JSON.parse(ev.data);
      if (msg.type === 'error') { alert(msg.message); return; }
      if (msg.type === 'init') {
        myId = msg.id;
        for (const pid of msg.peers) await createPeer(pid, true);
      }
      if (msg.type === 'peer-joined') {
        await createPeer(msg.id, false);
      }
      if (msg.type === 'peer-left') { dropPeer(msg.id); }
      if (msg.type === 'signal') {
        const pc = pcs.get(msg.from) || (await (async ()=>{ await createPeer(msg.from,false); return pcs.get(msg.from); })());
        if (msg.data.sdp) {
          await pc.setRemoteDescription(new RTCSessionDescription(msg.data.sdp));
          if (msg.data.sdp.type === 'offer') {
            const answer = await pc.createAnswer(); await pc.setLocalDescription(answer);
            ws.send(JSON.stringify({ type:'signal', target: msg.from, data:{ sdp: pc.localDescription } }));
          }
        } else if (msg.data.candidate) {
          try { await pc.addIceCandidate(new RTCIceCandidate(msg.data.candidate)); } catch {}
        }
      }
    };
  }
  function leaveRoom(){
    for (const pid of [...pcs.keys()]) dropPeer(pid);
    if (ws && ws.readyState === WebSocket.OPEN) ws.close();
    ws = null; myId = null; room = null; stopLocal();
  }

  btnJoin.onclick = async ()=>{ try{ await joinRoom(); } catch(e){ console.error(e); alert('Join failed: '+e.message); } };
  btnLeave.onclick = ()=> leaveRoom();
  btnShuffle.onclick = ()=> randomizeMySillies('manual');
  selMode.onchange = ()=>{ sillyMode = selMode.value; setChaosTimer(); };
  fxToggle.onchange = ()=>{ useFX = fxToggle.checked; replaceAudioTrackOnAllPCs(); };
  btnMute.onclick = ()=>{ const at = chooseAudioTrack(); if (at) { at.enabled = !at.enabled; btnMute.textContent = at.enabled ? 'Mute' : 'Unmute'; } };
  btnCamera.onclick = ()=>{ local.camOn = !local.camOn; const vt = local.stream?.getVideoTracks?.()[0]; if (vt) vt.enabled = local.camOn; btnCamera.textContent = local.camOn ? 'Camera' : 'Camera (off)'; };
  document.addEventListener('visibilitychange', ()=>{ if (document.visibilityState==='visible' && local.audioCtx) local.audioCtx.resume?.(); });
})();
</script>
</body>
</html>
